查找
1.符号表
	符号表最主要的目的就是将一个键和一个值联系起来
	是一种存储键值对的数据结构，支持两种操作：
		插入(pull)
		查找(get)
	1.1.API
		public class ST <key,value>
			ST()   创建一个符号表
			void put(Key key, Value value)
			value get(Key key)
			void deleted(Key key)
			boolean isEmpty()
			int size()
			Iterable<key> keys()	表中所有键的集合
		1.1.1.泛型
			对于符号表，明确的指出查找时键和值的类型来区分它们不同的角色
		1.1.2.重复的键
			每个键只对应一个值
			键冲突的时候，用 新键代替旧键
		1.1.3.空键
			不能为空
		1.1.4.空值
			不允许有空值
				可以用get()是否返回空来测试给定的键知存在符号表中
				可以用空值作为put()的第二个参数，用来删除
		1.1.5.删除
			延时删除：将键值对应的值为空 ，然后在某个时候删去所有值为空的键
			即时删除：立即从表中删除指定的键
		1.1.6.便捷方法
			void deleted(Key key)
				put(key,null)
			boolean contains(key)
				return get(key)!=null
			boolean isEmpty()
				return size ==0
		1.1.7.迭代
			implements Interable<key>
				强制所有的实现必须包换iterator(),来返回一个实现hasNext()和next()迭代器
		1.1.8.键的等价表	
			要确定一个键是否在符号表中，要确定对象等价概念
	1.2.有序符号表
		键都是Comparable对象，因此可以使用a.compareTo(b)来比较a和b两个键
		许多符号表的实现都利用了Comaprable接口带来的键的有序性更好的实现put()和get()
		符号表都会保持键的有序并大大扩展了它的API
		一种有序泛型符号表的API
			public class ST <Key extends Comparable<key>,Value>
				ST()
				void put(Key key, Value value)
				value get(Key key)
				void deleted(Key key)
				boolean isEmpty()
				boolean contains(Key key)
				int size()
				Iterable<key> keys()	表中所有键的集合
				Key min()
				Key max()
				Key floor(Key key)  小于等于最大键
				Key ceiling(Key key) 小于等于key的最小键
				int rank(Key key)   小于key的键的数量
				Key select(int k)   排名为k的键
			
			public class ST <Key extends Comparable<key>,Value>
				void deleteMin()
				void deleteMax()
				int size(Key lo, Key hi)
				Iterable<Key> keys(Key lo,Key hi) 已排序
				Iterbale<Key> keys() 表中所有键的集合
		1.2.1.最大键和最小键
			主要区别就是优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作越多。
		1.2.2.向下取数和向上取数
		1.2.3.排名和选择
			检验一个新的键插入合适位置的基本操作是排名rank，找出小于指定键的键的数量
		1.2.4.范围查找
		1.2.5.例外查找
		1.2.6.便捷方法
		1.2.7.键的等价性
			不会在符号列表中实现使用equals()，作为替代只会使用ComapareTo()
		1.2.8.成本模型
	1.3.测试
	1.4.无序链表的顺序查找		
		符号表中使用的数据结构是一个简单选择链表，每个节点存储是一个键值对。
		get()：遍历链表
		equals():比较被查找的键和每个节点中的键
		put()：也是遍历链表，用equals()比较被查找的键和每个结点的键
				如果匹配成功我们就用第二个参数指定的值更新和该键相关的值
				否则我们就用给定的键值来创建一个新的节点并将其插入到链表的开头
	1.5.有序数组的二分查找
		rank()返回表中小于给定的键的数量
		get()只要给定的键存在与表中，rank()方法就能够精确的找到
		put()只要给定的键存在表中，rank()告诉我们去哪里去更新它的值，以及当键不再表中时将键存储到表和何处，将所有更大的键
			向后移动一格腾出位置，并将给定的键值分别插入到各个数组的的合适位置。
		1.5.1.二分查找
	1.6.对二分查找的分析
		rank()的递归实现还能让我们得出结论
			二分查找很快，因为递归关系可以说明算法比较次数的上限
			在N个键的有序数组中进行二分查找需要更多LgN+1次比较
			public int rank(Key key ,int lo ,int hi){
				if(hi < lo ){
					return lo;
				}
				int mid = (lo + hi ) / 2;
				int com =key.ComparaeTo(keys[mid])
				if(com < 0){
					return rank(key ,lo, mid+1);
				}else if(com > 0){
					return rank(key, mid + 1, hi)
				}else {
					rturn mid;
				}
			}
		二分查找减少了比较次数但无法运行时间，无法改变以下事实：
			在键是随机排列的情况下，构造一个基于有序数组的符号表所需要的访问数组的次数是数组长度的平方级别
		在大小为N的有序数组插入一个新的元素在最坏的情况下需要访问——2N次数组
		因此要向一个空符号表中插入N个元素在最坏的情况下需要访问N²此数组。
2.二叉树查找
	将链表插入的灵活性 和有序数组查找的高效性结合起来的符号表的实现
	所需要的数据结构由结点组成，结点包含的链接可以指向空null或者其他节点
	在二叉树中
		每个结点只能由一个父结点指向自己，除了根节点，因为根节点没有父节点
		每个结点都有左右两个链接，分别指向自己的左子节点和右子节点
		尽管链接指向的是结点，把每个连接看做指向了另一颗二叉树，而这颗树的根节点就是被指向的结点
	将二叉树定义为一个空链接，或者一个有左右两个链接的结点，每个连接都指向一颗独立的子二叉树。
	在二叉查找数中，每个结点还包含了一个键和一个值，键之间也有顺序之分以支持高效的查找
	一颗二叉查找树是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）
	  且每个结点的键都大于其左子树的任何结点，小于右子树的任何结点。
	2.1.基本实现
		2.1.1数据表示