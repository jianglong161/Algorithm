查找
1.符号表
	符号表最主要的目的就是将一个键和一个值联系起来
	是一种存储键值对的数据结构，支持两种操作：
		插入(pull)
		查找(get)
	1.1.API
		public class ST <key,value>
			ST()   创建一个符号表
			void put(Key key, Value value)
			value get(Key key)
			void deleted(Key key)
			boolean isEmpty()
			int size()
			Iterable<key> keys()	表中所有键的集合
		1.1.1.泛型
			对于符号表，明确的指出查找时键和值的类型来区分它们不同的角色
		1.1.2.重复的键
			每个键只对应一个值
			键冲突的时候，用 新键代替旧键
		1.1.3.空键
			不能为空
		1.1.4.空值
			不允许有空值
				可以用get()是否返回空来测试给定的键知存在符号表中
				可以用空值作为put()的第二个参数，用来删除
		1.1.5.删除
			延时删除：将键值对应的值为空 ，然后在某个时候删去所有值为空的键
			即时删除：立即从表中删除指定的键
		1.1.6.便捷方法
			void deleted(Key key)
				put(key,null)
			boolean contains(key)
				return get(key)!=null
			boolean isEmpty()
				return size ==0
		1.1.7.迭代
			implements Interable<key>
				强制所有的实现必须包换iterator(),来返回一个实现hasNext()和next()迭代器
		1.1.8.键的等价表	
			要确定一个键是否在符号表中，要确定对象等价概念
	1.2.有序符号表
		键都是Comparable对象，因此可以使用a.compareTo(b)来比较a和b两个键
		许多符号表的实现都利用了Comaprable接口带来的键的有序性更好的实现put()和get()
		符号表都会保持键的有序并大大扩展了它的API
		一种有序泛型符号表的API
			public class ST <Key extends Comparable<key>,Value>
				ST()
				void put(Key key, Value value)
				value get(Key key)
				void deleted(Key key)
				boolean isEmpty()
				boolean contains(Key key)
				int size()
				Iterable<key> keys()	表中所有键的集合
				Key min()
				Key max()
				Key floor(Key key)  小于等于最大键
				Key ceiling(Key key) 小于等于key的最小键
				int rank(Key key)   小于key的键的数量
				Key select(int k)   排名为k的键
			
			public class ST <Key extends Comparable<key>,Value>
				void deleteMin()
				void deleteMax()
				int size(Key lo, Key hi)
				Iterable<Key> keys(Key lo,Key hi) 已排序
				Iterbale<Key> keys() 表中所有键的集合
		1.2.1.最大键和最小键
			主要区别就是优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作越多。
		1.2.2.向下取数和向上取数
		1.2.3.排名和选择
			检验一个新的键插入合适位置的基本操作是排名rank，找出小于指定键的键的数量
		1.2.4.范围查找
		1.2.5.例外查找
		1.2.6.便捷方法
		1.2.7.键的等价性
			不会在符号列表中实现使用equals()，作为替代只会使用ComapareTo()
		1.2.8.成本模型
	1.3.测试
	1.4.无序链表的顺序查找		
		符号表中使用的数据结构是一个简单选择链表，每个节点存储是一个键值对。
		get()：遍历链表
		equals():比较被查找的键和每个节点中的键
		put()：也是遍历链表，用equals()比较被查找的键和每个结点的键
				如果匹配成功我们就用第二个参数指定的值更新和该键相关的值
				否则我们就用给定的键值来创建一个新的节点并将其插入到链表的开头
	1.5.有序数组的二分查找
		rank()返回表中小于给定的键的数量
		get()只要给定的键存在与表中，rank()方法就能够精确的找到
		put()只要给定的键存在表中，rank()告诉我们去哪里去更新它的值，以及当键不再表中时将键存储到表和何处，将所有更大的键
			向后移动一格腾出位置，并将给定的键值分别插入到各个数组的的合适位置。
		1.5.1.二分查找
	1.6.对二分查找的分析
		rank()的递归实现还能让我们得出结论
			二分查找很快，因为递归关系可以说明算法比较次数的上限
			在N个键的有序数组中进行二分查找需要更多LgN+1次比较
			public int rank(Key key ,int lo ,int hi){
				if(hi < lo ){
					return lo;
				}
				int mid = (lo + hi ) / 2;
				int com =key.ComparaeTo(keys[mid])
				if(com < 0){
					return rank(key ,lo, mid+1);
				}else if(com > 0){
					return rank(key, mid + 1, hi)
				}else {
					rturn mid;
				}
			}
		二分查找减少了比较次数但无法运行时间，无法改变以下事实：
			在键是随机排列的情况下，构造一个基于有序数组的符号表所需要的访问数组的次数是数组长度的平方级别
		在大小为N的有序数组插入一个新的元素在最坏的情况下需要访问——2N次数组
		因此要向一个空符号表中插入N个元素在最坏的情况下需要访问N²此数组。
2.二叉树查找
	将链表插入的灵活性 和有序数组查找的高效性结合起来的符号表的实现
	所需要的数据结构由结点组成，结点包含的链接可以指向空null或者其他节点
	在二叉树中
		每个结点只能由一个父结点指向自己，除了根节点，因为根节点没有父节点
		每个结点都有左右两个链接，分别指向自己的左子节点和右子节点
		尽管链接指向的是结点，把每个连接看做指向了另一颗二叉树，而这颗树的根节点就是被指向的结点
	将二叉树定义为一个空链接，或者一个有左右两个链接的结点，每个连接都指向一颗独立的子二叉树。
	在二叉查找数中，每个结点还包含了一个键和一个值，键之间也有顺序之分以支持高效的查找
	一颗二叉查找树是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）
	  且每个结点的键都大于其左子树的任何结点，小于右子树的任何结点。
	2.1.基本实现
		2.1.1数据表示
			嵌套定义一个私有类来表示二叉树上的一个结点
			每个结点都含有一个键，一个值，一条左连接，一条右连接和一个结点计数器
			左连接指向一颗小于该结点的所有键组成的二叉树
			右连接指向一颗大于该结点的所有键组成的二叉树
			一颗二叉树代表了键的集合，而同一个集合可以用多颗不同的二叉查找树来表示
		2.1.2.查找
			在二叉树中查找一个键的递归算法：
				如果树是空的，则未查找命中
				如果被查找的键和根节点的键相同，查找命中
				否则就递归的在适当的子树中进行查找
				如果被查找的键较小，就选择左子树，如果较大，就选择右子树
			从根节点开始，在每个结点中查找的进程都会递归的在它的一个子结点中展开
			  因此一次查找也就定义了树的一条路径	
			对于命中的查找，路径在含有被查找的键的结点处结束。
			对于未命中的查找，路径的终点是一个空连接。
		2.1.3.插入
			和查找的逻辑一样
		2.1.4.递归
			将递归调用前的代码想想成沿着树向下走
				会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点
			将递归调用后的代码想象成沿着树向上爬
			对于get()对应着一些列的返回指令
			对于put()
				重置搜索路径上的每个父节点指向子节点的链接，并增加路径上每个结点中的计数器的值。
			新结点会链接到树的最底层的空连接上，树的其他部分则不会变
	2.2.分析
		运行时间取决于树的形状，而树的形状又取决于键先后被查的顺序
		在N个随机键组成的二叉查找树中 ，查找命中的平均所需的次数为2lnN
	2.3.有序性相关方法和删除操作
		二叉查找树能保持键的有序性
		2.3.1.最大键和最小键
			如果根节点的左连接为空，那么一颗二叉查找树的最小的键就是根节点
			如果左连接非空，那么最小的键就是左子树中最小的键
			最大的键就是右
		2.3.2.向上取整和向下取整
			如果给定的键key小于二叉查找树的根结点的键，那么 小于等于key的最大键floor一定在根节点的左子树
			如果给定的键key大于二叉查找树的跟结点的键，那么只有当根的右子树中存在小于等于key的结点时，
			  小于等于key的最大键才会出现在右子树，否则根节点就是小于等于key的最大键
		2.3.3.选择操作
			二叉查找树的每个结点中维护的子树结点计数器变量N就是用来支持此操作的。
		2.3.4.排名
			rank()是select()的逆方法，它会反给定键的排名，实现和select()相似：
				如果给定的键和根结点相等，我们就返回左子树中的结点总数t
				如果给定的键小于根节点，返回该键在左子树的排名，递归计算
				给定的键大于根节点，返回t+1根节点加上它在右子树的排名
		2.3.5.删除最大键和最小键
			对于deleteMin()
				要不断根结点的左子树直至遇到一个空连接，然后将指向该结点的链接指向右子树
		2.3.6.删除操作
			删除一个结点中带着2个子节点
				在删除结点x以后用它的后继节点填补它的位置
				因为x有一个右子节点，后继节点就是它右子树的最小结点
			用4个步骤完成将x替换为它的后继结点的任务：
				将指向即将被删除的结点的连接保存为t；
				将x指向它的后继结点min(t.right);
				将x的右链接（原本指向一颗所有结点都大于x.key的二叉查找树）指向deleteMin（t.right）
				   也就是删除后所有的结点仍然都大于x.key的子二叉查找树；
				将x的左连接（本为空）设为t.left（其下所有的键都小于被删除的结点和它的后继结点）
		2.3.7.范围查找
				中序遍历
3.平衡查找树
	3.1. 2-3查找树
		将一颗标准二叉树的结点成为2-结点(含有一个键和二条链接)
		引入3-结点（含有两个键和三条链接）
			左连接小于，中连接位于该结点和两个键之间。
		2-结点和3-结点每条链接都对应着其中保存的键所分割产生的一个区间。
		3.1.1.查找
			要判断一个键是否在树中，先将它和根节点中的键比较，如果它和任意一个相等，查找命中，
			否则就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续寻找，如果是个空连接，则没有命中
		3.1.2.向2-结点中插入新键
			先进性一次未命名的查找，然后把新结点挂在树的底部，但是这样的话就无法保持完美平衡性
			如果未命中的查找结束与一个2-结点，只要把这个2-结点替换为一个3-结点，将插入的键保存在其中即可。
			如果未查找命中3-结点，事情比较麻烦
		3.1.3.向一颗只含有一个3-结点的树中插入新键
			先临时将该键存入该结点中，成为一个4-结点，很容易的扩展了以前的结点并含有3个键和4条链接
			创建一个4-结点很方便，转换成一颗由3个2-结点组成的2-3树：
				其中一个结点还有中键，
				一个结点中含有3个键中的最小者和根节点的左连接相连
				一个结点中含有3个键中的最大者和根节点的右链接项链
			这棵树既是一颗含有3个结点的二叉树也是一颗完美平衡的2-3树
		3.1.4.向一个父节点为2-结点的3-结点中插入新键
			未命中的键是一个3-结点，但是父节点为2-结点
			先构造一个临时的4-结点并分解，不为中键创造一个新结点，而是将其移动到原来的父节点中
		3.1.5.向一个父节点为3-结点的3-结点中插入新键
			先构造一个临时的4-结点并分解，在用这个中键构造一个新的临时4结点，然后在这个结点中进行临时的变换
		3.1.6.分解根节点
			将4-结点分解为3个2-结点，树高加1
		3.1.7.局部变换
		3.1.8.全局性质
			任意空链接到根节点的路径长度都是相等的额。
			
			
				