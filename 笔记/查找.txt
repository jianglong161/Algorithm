查找
1.符号表
	符号表最主要的目的就是将一个键和一个值联系起来
	是一种存储键值对的数据结构，支持两种操作：
		插入(pull)
		查找(get)
	1.1.API
		public class ST <key,value>
			ST()   创建一个符号表
			void put(Key key, Value value)
			value get(Key key)
			void deleted(Key key)
			boolean isEmpty()
			int size()
			Iterable<key> keys()	表中所有键的集合
		1.1.1.泛型
			对于符号表，明确的指出查找时键和值的类型来区分它们不同的角色
		1.1.2.重复的键
			每个键只对应一个值
			键冲突的时候，用 新键代替旧键
		1.1.3.空键
			不能为空
		1.1.4.空值
			不允许有空值
				可以用get()是否返回空来测试给定的键知存在符号表中
				可以用空值作为put()的第二个参数，用来删除
		1.1.5.删除
			延时删除：将键值对应的值为空 ，然后在某个时候删去所有值为空的键
			即时删除：立即从表中删除指定的键
		1.1.6.便捷方法
			void deleted(Key key)
				put(key,null)
			boolean contains(key)
				return get(key)!=null
			boolean isEmpty()
				return size ==0
		1.1.7.迭代
			implements Interable<key>
				强制所有的实现必须包换iterator(),来返回一个实现hasNext()和next()迭代器
		1.1.8.键的等价表	
			要确定一个键是否在符号表中，要确定对象等价概念
	1.2.有序符号表
		键都是Comparable对象，因此可以使用a.compareTo(b)来比较a和b两个键
		许多符号表的实现都利用了Comaprable接口带来的键的有序性更好的实现put()和get()
		符号表都会保持键的有序并大大扩展了它的API
		一种有序泛型符号表的API
			public class ST <Key extends Comparable<key>,Value>
				ST()
				void put(Key key, Value value)
				value get(Key key)
				void deleted(Key key)
				boolean isEmpty()
				boolean contains(Key key)
				int size()
				Iterable<key> keys()	表中所有键的集合
				Key min()
				Key max()
				Key floor(Key key)  小于等于最大键
				Key ceiling(Key key) 小于等于key的最小键
				int rank(Key key)   小于key的键的数量
				Key select(int k)   排名为k的键
			
			public class ST <Key extends Comparable<key>,Value>
				void deleteMin()
				void deleteMax()
				int size(Key lo, Key hi)
				Iterable<Key> keys(Key lo,Key hi) 已排序
				Iterbale<Key> keys() 表中所有键的集合
		1.2.1.最大键和最小键
			主要区别就是优先队列中可以存在重复的键但符号表中不行，而且有序符号表支持的操作越多。
		1.2.2.向下取数和向上取数
		1.2.3.排名和选择
			检验一个新的键插入合适位置的基本操作是排名rank，找出小于指定键的键的数量
		1.2.4.范围查找
		1.2.5.例外查找
		1.2.6.便捷方法
		1.2.7.键的等价性
			不会在符号列表中实现使用equals()，作为替代只会使用ComapareTo()
		1.2.8.成本模型
	1.3.测试
	1.4.无序链表的顺序查找		
		符号表中使用的数据结构是一个简单选择链表，每个节点存储是一个键值对。
		get()：遍历链表
		equals():比较被查找的键和每个节点中的键
		put()：也是遍历链表，用equals()比较被查找的键和每个结点的键
				如果匹配成功我们就用第二个参数指定的值更新和该键相关的值
				否则我们就用给定的键值来创建一个新的节点并将其插入到链表的开头
	1.5.有序数组的二分查找
		rank()返回表中小于给定的键的数量
		get()只要给定的键存在与表中，rank()方法就能够精确的找到
		put()只要给定的键存在表中，rank()告诉我们去哪里去更新它的值，以及当键不再表中时将键存储到表和何处，将所有更大的键
			向后移动一格腾出位置，并将给定的键值分别插入到各个数组的的合适位置。
		1.5.1.二分查找
	1.6.对二分查找的分析
		rank()的递归实现还能让我们得出结论
			二分查找很快，因为递归关系可以说明算法比较次数的上限
			在N个键的有序数组中进行二分查找需要更多LgN+1次比较
			public int rank(Key key ,int lo ,int hi){
				if(hi < lo ){
					return lo;
				}
				int mid = (lo + hi ) / 2;
				int com =key.ComparaeTo(keys[mid])
				if(com < 0){
					return rank(key ,lo, mid+1);
				}else if(com > 0){
					return rank(key, mid + 1, hi)
				}else {
					rturn mid;
				}
			}
		二分查找减少了比较次数但无法运行时间，无法改变以下事实：
			在键是随机排列的情况下，构造一个基于有序数组的符号表所需要的访问数组的次数是数组长度的平方级别
		在大小为N的有序数组插入一个新的元素在最坏的情况下需要访问——2N次数组
		因此要向一个空符号表中插入N个元素在最坏的情况下需要访问N²此数组。
2.二叉树查找
	将链表插入的灵活性 和有序数组查找的高效性结合起来的符号表的实现
	所需要的数据结构由结点组成，结点包含的链接可以指向空null或者其他节点
	在二叉树中
		每个结点只能由一个父结点指向自己，除了根节点，因为根节点没有父节点
		每个结点都有左右两个链接，分别指向自己的左子节点和右子节点
		尽管链接指向的是结点，把每个连接看做指向了另一颗二叉树，而这颗树的根节点就是被指向的结点
	将二叉树定义为一个空链接，或者一个有左右两个链接的结点，每个连接都指向一颗独立的子二叉树。
	在二叉查找数中，每个结点还包含了一个键和一个值，键之间也有顺序之分以支持高效的查找
	一颗二叉查找树是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关的值）
	  且每个结点的键都大于其左子树的任何结点，小于右子树的任何结点。
	2.1.基本实现
		2.1.1数据表示
			嵌套定义一个私有类来表示二叉树上的一个结点
			每个结点都含有一个键，一个值，一条左连接，一条右连接和一个结点计数器
			左连接指向一颗小于该结点的所有键组成的二叉树
			右连接指向一颗大于该结点的所有键组成的二叉树
			一颗二叉树代表了键的集合，而同一个集合可以用多颗不同的二叉查找树来表示
		2.1.2.查找
			在二叉树中查找一个键的递归算法：
				如果树是空的，则未查找命中
				如果被查找的键和根节点的键相同，查找命中
				否则就递归的在适当的子树中进行查找
				如果被查找的键较小，就选择左子树，如果较大，就选择右子树
			从根节点开始，在每个结点中查找的进程都会递归的在它的一个子结点中展开
			  因此一次查找也就定义了树的一条路径	
			对于命中的查找，路径在含有被查找的键的结点处结束。
			对于未命中的查找，路径的终点是一个空连接。
		2.1.3.插入
			和查找的逻辑一样
		2.1.4.递归
			将递归调用前的代码想想成沿着树向下走
				会将给定的键和每个结点的键相比较并根据结果向左或者向右移动到下一个结点
			将递归调用后的代码想象成沿着树向上爬
			对于get()对应着一些列的返回指令
			对于put()
				重置搜索路径上的每个父节点指向子节点的链接，并增加路径上每个结点中的计数器的值。
			新结点会链接到树的最底层的空连接上，树的其他部分则不会变
	2.2.分析
		运行时间取决于树的形状，而树的形状又取决于键先后被查的顺序
		在N个随机键组成的二叉查找树中 ，查找命中的平均所需的次数为2lnN
	2.3.有序性相关方法和删除操作
		二叉查找树能保持键的有序性
		2.3.1.最大键和最小键
			如果根节点的左连接为空，那么一颗二叉查找树的最小的键就是根节点
			如果左连接非空，那么最小的键就是左子树中最小的键
			最大的键就是右
		2.3.2.向上取整和向下取整
			如果给定的键key小于二叉查找树的根结点的键，那么 小于等于key的最大键floor一定在根节点的左子树
			如果给定的键key大于二叉查找树的跟结点的键，那么只有当根的右子树中存在小于等于key的结点时，
			  小于等于key的最大键才会出现在右子树，否则根节点就是小于等于key的最大键
		2.3.3.选择操作
			二叉查找树的每个结点中维护的子树结点计数器变量N就是用来支持此操作的。
		2.3.4.排名
			rank()是select()的逆方法，它会反给定键的排名，实现和select()相似：
				如果给定的键和根结点相等，我们就返回左子树中的结点总数t
				如果给定的键小于根节点，返回该键在左子树的排名，递归计算
				给定的键大于根节点，返回t+1根节点加上它在右子树的排名
		2.3.5.删除最大键和最小键
			对于deleteMin()
				要不断根结点的左子树直至遇到一个空连接，然后将指向该结点的链接指向右子树
		2.3.6.删除操作
			删除一个结点中带着2个子节点
				在删除结点x以后用它的后继节点填补它的位置
				因为x有一个右子节点，后继节点就是它右子树的最小结点
			用4个步骤完成将x替换为它的后继结点的任务：
				将指向即将被删除的结点的连接保存为t；
				将x指向它的后继结点min(t.right);
				将x的右链接（原本指向一颗所有结点都大于x.key的二叉查找树）指向deleteMin（t.right）
				   也就是删除后所有的结点仍然都大于x.key的子二叉查找树；
				将x的左连接（本为空）设为t.left（其下所有的键都小于被删除的结点和它的后继结点）
		2.3.7.范围查找
				中序遍历
3.平衡查找树
	3.1. 2-3查找树
		将一颗标准二叉树的结点成为2-结点(含有一个键和二条链接)
		引入3-结点（含有两个键和三条链接）
			左连接小于，中连接位于该结点和两个键之间。
		2-结点和3-结点每条链接都对应着其中保存的键所分割产生的一个区间。
		3.1.1.查找
			要判断一个键是否在树中，先将它和根节点中的键比较，如果它和任意一个相等，查找命中，
			否则就根据比较的结果找到指向相应区间的连接，并在其指向的子树中递归地继续寻找，如果是个空连接，则没有命中
		3.1.2.向2-结点中插入新键
			先进性一次未命名的查找，然后把新结点挂在树的底部，但是这样的话就无法保持完美平衡性
			如果未命中的查找结束与一个2-结点，只要把这个2-结点替换为一个3-结点，将插入的键保存在其中即可。
			如果未查找命中3-结点，事情比较麻烦
		3.1.3.向一颗只含有一个3-结点的树中插入新键
			先临时将该键存入该结点中，成为一个4-结点，很容易的扩展了以前的结点并含有3个键和4条链接
			创建一个4-结点很方便，转换成一颗由3个2-结点组成的2-3树：
				其中一个结点还有中键，
				一个结点中含有3个键中的最小者和根节点的左连接相连
				一个结点中含有3个键中的最大者和根节点的右链接项链
			这棵树既是一颗含有3个结点的二叉树也是一颗完美平衡的2-3树
		3.1.4.向一个父节点为2-结点的3-结点中插入新键
			未命中的键是一个3-结点，但是父节点为2-结点
			先构造一个临时的4-结点并分解，不为中键创造一个新结点，而是将其移动到原来的父节点中
		3.1.5.向一个父节点为3-结点的3-结点中插入新键
			先构造一个临时的4-结点并分解，在用这个中键构造一个新的临时4结点，然后在这个结点中进行临时的变换
		3.1.6.分解根节点
			将4-结点分解为3个2-结点，树高加1
		3.1.7.局部变换
		3.1.8.全局性质
			任意空链接到根节点的路径长度都是相等的额。
	3.2.红黑二叉查找树
		3.2.1.替换3-结点
			红黑二叉查找树的标准思想就是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息来表示2-3树
			将数中的连接分为两个：
				红连接将两个2-结点连接起来构成一个3-结点
				黑连接则是2-3树的普通连接
			将3-结点表示为由一条左斜的红色连接（两个2-结点其中之一是另一个的左子结点）相连的两个2-结点
			可以直接用标准的get()方法
		3.2.3.一一对应
			将一颗红黑树的红连接画平，那么所有的空连接到根节点的距离都是相同
			如果将红链接相连的结点合并，就是一颗2-3树
			如果将一颗2-3树中的3-结点作为红色左连接项链的两个2-结点，那么不会存在能够和两条红链接相连的结点
			   且树必然是完美平衡的，
			红黑树既是二叉查找树也是2-3树
		3.2.4.颜色表示
			将链接的颜色保存在表示结点的Node数据类型的布尔变量color中
			如果指向它的颜色为红色，则true，黑色false，默认空连接为黑色
			isRed()测试一个结点和它的父节点之间连接的颜色
			提到结点的颜色，指的是指向该结点的连接的颜色。
		3.2.5.旋转
			旋转操作会改变红链接的指向。
			红色的右连接需要被转换成左连接，操作叫左旋转：
				接受一条指向红黑树中的某个结点的链接作为参数
			只要将两个键中的较小者作为根结点变为将较大者作为根节点。
		3.2.6.在旋转后重置父结点的链接
			用rotateRight()的返回值重置父结点中相应的连接
			返回的链接可能是左连接或者右链接，但是总会将它赋予父节点中链接。
		3.2.7.向2-结点中插入新键
			一颗只含有一个键的红黑树只含一个2-结点
			插入一个键以后，马上需要将它们旋转
			如果新键小于老键，只需增一个红色的结点，新的红黑树和单个3-结点完全等价
			如果新键大于老键，那么新增的红色结点会产生一条红色的右链接
			 用root = rotateleft()来将其旋转为红色左连接，并修正根节点的连接，才算操作完成
			结果均为一颗和单个3-结点等价的红黑树，其中含有两个键，一条红链接，树的黑连接高度为1.
		3.2.8.向底部的2-结点插入新键
			用二叉查找树相同的方式像一颗红黑树中插入一个新键会在树的底部新增一个结点，但总是用红连接将新结点和它的父节点相连
			如果父节点是2-结点
				两种方法都适用
			如果指向新结点的是父节点的左连接，那么父节点是一个3-结点
			如果指向新结点的是父节点的右连接，那么父节点是一个错误3-结点，用一次左旋转修复它。
		3.2.9.向一颗双键树即一个3-结点插入新建
			新键大于原树中的两个键：
				被连接到3-结点的右链接
				此时树是平衡的额
				根的结点为中间大小键
				两条红链接分别链着较小和较大的结点
				将两条链接的颜色都由红变黑，得到了一颗3个结点组成，高为2的平衡树，正好对应一颗2-3树
			新键小于原树中的两个键
				链接到最左边的空连接
				产生了两条连续的红连接
				只需要将上层的红链接右旋转可得到中值键为根节点并和其他两个结点用红链接相连
			如果新建介于两个键之间
				又会产生两条连续的红连接，一条红色左链接接一条红色右连接
				只需要将下层红链接左旋转即可得到第二种情况两条连续的红色连接
		3.2.10.颜色转换
		3.2.11.根结点总是为黑色
			每次插入后都会将根节点设置为黑色
		3.3.12.向树底部的3-结点插入新键
			指向新结点的连接可能是3-结点的右链接
				只需要转换颜色即可
			左连接
				进行右转换在转换颜色
			中连接
				先做转换下层连接，在右转换上层连接，最后在转换颜色
			颜色转换会使结点中的连接变红，相当于将它送入了父结点
		3.3.13.将红链接在树中向上传递。
			如果右子节点是红色而左子节点是黑色，进行左旋转
			如果左子节点是红色，且它的左子节点也是红色，进行右旋转
			左右结点皆为红色，颜色转换
	3.4.删除操作
		不仅要在为了删除一个结点而构造临时4-结点时沿着查找路径向下进行变换
		还要在分解遗留的4-结点时沿着查找路径向上进行变化同插入操作
		3.4.1.自顶向下的2-3-4树
			插入算法：
				沿查找路径向下变换是为了保证当前节点不是4-结点,这样树底才有空间来插新的键
				沿查找路径向上变换是为了将之前创建的4-结点配平
				如果根节点是4-结点，就将它分解为3个2-结点，使得树高加1
				在向下的过程中，如果遇到一个父结点为2-结点的4-结点：
					将4-结点分解为2个2-结点
					并将中间键传递给它的父节点，使得父节点变为一个4-结点。
			插入新的键，要用红黑算法实现这个算法，需要：
				将4-结点表示为三个2-结点组成的一颗平衡的子树，将结点和两个子结点都用红链接相连
				在向下的过程中分解所有的4-结点并进行颜色转换
				和插入操作一样，在向上的过程中用旋转将4-结点配平。
		3.4.2.删除最小键
			为了保证不会删除一个2-结点
			沿着左连接向下进行变换，确保当前结点不是2-结点。：
				如果根是2-结点且它的两个子节点都是2-结点，把这三个结点直接变为一个4-结点
			否则需要保证根的左结点不是一个2-结点
			在沿着左连接向下的过程中：
				如果当前结点的左子树不是2-结点，完成
				如果当前的左子树是2-结点，而它的亲兄弟结点不是2-结点
					将左子结点的兄弟结点中的一个键移动到左子结点中
				如果当前的结点的左子结点和它的兄弟结点都是2-结点，
					将左子结点，父结点中的最小键和左子结点最近的兄弟结点中合并为一个4-结点。
					使父节点由一个3-结点变为2-结点。
		3.4.3.删除操作
	3.5.红黑树的性质
4.散列表
	分两步：
	1.用散列函数将被查找的键转化为一个数组的索引
	2.处理碰撞冲突：
		拉链法
		线性探测法
	4.1.散列函数
		过程是将键转换成索引
		对于每种类型的键我们都需要一个与之对应的散列函数
		4.1.1.典型列子
			美国社保号
			123-45-6789
		4.1.2.正整数
			将整数散列最常用的方法就是除留余数法：
				选择大小为素数M的数组
				对于任意正整数k，
				计算k除以M的余数
				k%M
				有效将键分布在0到M-1的范围内
		4.1.3.浮点数
			如果键是从0到1的数
				乘以M,
				得到一个从0到M-1的之间的索引值
			将键表示为二进制然后再使用除留余数法
		4.1.4.字符窜
			将字符串当作大整数
			int hash = 0 
			for(int i = 0; i<s.lenght(); i++)
				hash = (R * hash + s.charAt(i)) % M;
		4.1.5.组合键
			如果键的类型还有多个整型变量，可以和String类型一样将它们组合起来
			比如date
				int hash = (((day * R + mouth) % M) * R + year) % M
		4.1.6.Java约定
			java令所有的数据类型都继承一个能够返回的hashCode()
			每一种的hashCode()都必须和equals()一致
		4.1.7.将hashCode()的返回值转换为一个数组索引
			需要一个数组缩影，而不是一个32位的整数
			在实现中将默认的hashCode()方法和除留余数法相结合起来产生一个0到M-1的整数
				private int hash(Key x){
					return (x.hashCode() & 0x7ffffff)
				}
		4.1.8.自定义的hashCode()
			public class Transaction{
				private final String who;
				private final Date when;
				private fianl Double amout;
				public int hashCode(){
					int hash = 17;
					hash = 31 * hash + who.hashCode();
					hash = 31 * hash + when.hashCode();
					hash = 31 * hash + amout.hashCode;
					return hash;
				}
			}
		4.1.9.软缓存
			如果散列值的计算很耗时，可以将每个键的散列值缓存起来。
			在
		
			
			
				