1.无向图
	边edge仅仅是两个顶点vertex之间的连接
	图是由一组顶点和能够将两个定点相连的边组成。
	使用0到V-1表示一张还有V个顶点的图中的各个顶点
	自环：
		即一条连接一个顶点和其自身的边
	连接同一顶点的两条边称为平行边。
	含有平行边的图成为多重图，没有平行边或自环的图为简单图。
	1.1.术语表
		当两个顶点通过一条边相连时，称呼这两个顶点为相邻，并称该链接依附于两个顶点。
		某个顶点的度数极为依附于它边的总数
		子图是由一幅图的所有变的子集以及它们所依附的顶点组成的图
		路径是有边顺序连接的一系列顶点。
		简单路径是没有重复顶点的路径
		环是一条至少含有一条边且起点和终点相同的路径
		如果从任意一个顶点都存在一条路径到达另一个任意顶点，称这幅图为连通图
		一副非连通的图由若干连通组成，它们都是其极大连通子图
		树是一副无环连通图
		互不相连的树组成的集合成为森林
		当一颗含有V个结点的图G满足下列5个条件之一时，就是一棵树：
			G有V-1条边且不含环
			G有V-1条边且是连通
			G是连通的，但是删除任意一条边都会使它不再连通
			G是无图的，但添加任意一条边都会产生一条环
			G的任意一对顶点之间存在一条简单路径
	1.2.表示无向图的数据类型
		public class Graph{
			Graph(int  V);//创建一个含有V个顶点但是不含有边的图
			Graph(int in);//从标准输入流in读入一副图
			int V(); 顶点数
			int E();边数
			void addEdge(int v,int w);向图中添加一条边v-w
			Iterable<Integer> adj(int v); 和v相邻的所有顶点
			String toString() 
		}
		1.2.1.图的几种表示方法
			面对的下一个图处理问题就是用哪种方式，来表示图并实现这份API,包含两个要求：
				它必须为可能在应用中碰到的各种类型的图预留出足够时间
				Graph的实例方法的实现一定要块----它们是开发处理图的各种用例的基础
			在三种图的表示方法中进行选择：
				邻接矩阵：
					V乘V的布尔矩阵
					当顶点v和顶点w之间相连的边时，定义v行w列的元素值为true，否则为false
					不符合第一个条件--含有上百万个顶点的图是很常见，V2个布尔值的所需要的空间是不满足的
				边的数组：
					使用一个Edge类，它含有两个int实例变量。
					不满足第二个条件--要实现adj()需要检查图中的所有边
				邻接表数组：
					使用一个顶点为索引的列表数组
					其中每个元素都是和该顶点相邻的顶点列表
		1.2.2.邻接表的数据类型
			非稠密图的标准表示称为邻接表的数据结构，
			将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。
			使用这个数组为了快速访问给定顶点的邻接表
		1.2.3.图的处理算法的设计模式
			将图的表示和实现分离开来。
	1.3.深度优先搜索
		常常通过系统地检查每一个顶点和每一条边来获取图的各种性质
		但是常常和路径有关
		1.3.1.走迷宫
			用迷宫代替图，通道代替边，路口代替顶点
			搜素迷宫而不迷路是个古老的方法叫做-Tremaux搜索
			要搜索完迷宫的所有通道：
				选择一条没有标记过的通道，在你走过的路上铺一条绳子
				标记所有你第一次路过的路口和通道
				当来到第一个标记的路口时回退到上一个路口
				当回退到路口已没有可走的通道时继续回退
		1.3.2.热身
			要搜索一幅图，只需用一个递归方法来遍历所有顶点，在访问一个顶点的时候：
				将它标记为已访问
				递归的访问他的所有没有被标记过的邻居顶点。
			称为深度优先搜索(DFS)
				使用一个boolean数组来记录和起点连通的所有顶点
				递归的方法会标记给定的顶点并调用自己来访问该顶点相邻顶点列表中所有没有被标记过的顶点
			深度优先搜索标记与起点连通的所有顶点所需要的额时间和顶点的度数成反比。
		1.3.3.单向通道
			代码中方法的调用和返回机制对应迷宫中绳子的作用
		1.3.4.跟踪深度优先搜索
			算法遍历边和访问顶点的顺序与图的表示是有关的，而不只是与图的结构或算法有关。
			因为深度优先搜索只会访问和起点连通的顶点
			深度优先搜素中每条边都会访问两次，且第二次时总会发现这个顶点已经被标记过关。
		1.3.5.深度优先搜索的详细轨迹
			连通性：
				给定一个图回答“两个给定顶点是否连通”或者“图中有多少个连通子图”
			单点路径：
				给定一副图和一个起点s，从s到给定目的顶点v是否存在一条路径
	1.4.寻找路径
		public clss path(){
			Path(Graph g, int s)	//在G图中找到起点为s的路径
			bollean haspathto（int v）	//是否存在s到v的路径
			Iterable<Integer> pathTo(int v)//s到v的路径，如果不存在则返回nul
		}
		1.4.1.实现
	1.5.广度优先搜索
		深度优先搜索得到的路径不仅取决于图的结构，还取决于图的表示和递归调用的性质
		找出单点路径中的最短的路径，叫广度优先搜索BFS
		要找到从s到v的最短路径：
			从s开始，在所有的一条边就可以到达的顶点寻求v，
			如果找不到，我们就继续在与s的距离两条边的所有顶点中查找v
		广度优先搜索好像一组人在一起朝各个方向走这座迷宫：
			当出现新的叉路的时候，可以假设一个探险者可以分裂为更多的人来搜索它们
			当两个探险者相遇，会合二为一。
		实现：
			使用了一个队列来保存所有被标记过但其邻接表还未被检查过的顶点。
			先将起点加入队列，然后重复以下步骤直到队列为空：
				去队列中的下一个顶点v并标记它；
				将与v相邻的所有未被标记过的顶点加入队列。
		对于从s可达的任意顶点v,广度优先搜索的都能找到一条从 s到v的最短路径
		在搜索中我们都将起点放入数据结构中，然后重复以下的步骤直到数据结构被清空：
			取其中的下一个顶点并标记。
			将v的所有相邻而又未被标记的顶点加入数据结构。
		这两个算法不同之处仅在于从数据结构中获取下一个顶点的规则：
			对于广度优先来说是最早加入的顶点
			对于深度优先来说是最晚加入的顶点
	1.6.连通分量
		深度优先搜索的下一个直接应用就是找出一副图所有的连通分量
			public class CC
				CC(Graphc G)//预处理构造函数
				boolean connceted(int v,int w)	//v和w是连通的么
				int count()//连通分量数
				int id;//v所在的连通分量的标识符（0-count-1）
		1.6.1.实现
			CC的实现，使用了marked[]数组来寻找一个顶点作为每个连通分量中深度优先搜索的起点。
			递归的深度优先搜索第一次调用的参数是顶点0，它会标记所有与0连通的顶点
		1.6.2.union-find算法
			理论上深度优先比union-find快，因为能保证所需要的时间是常数，而uniod算法不行。
	1.7.符号图
		在典型应用中，使用的都是字符串而非整数来表示和指代顶点，定义以下性质的输入格式：
			顶点名为字符串
			用指定的分隔符来隔开顶点名，允许顶点含有空格
			每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示顶点和其他名称所表示的顶点。
			顶点总数V和边的总数E都是隐式定义
		1.7.1.API
			public class SymbolGraph
				SymbolGraph(String fileName, String delim)	//根据filename指定的文件构造图，使用delim来分隔顶点
				boolean contains(String key) //key是一个顶点么
				int index(String key)	//key是索引
				String name(int v)	/索引v是顶点名
				Graph G()	//隐藏的Graph对象
				用name()和index()将输入流中的顶点名和图算法使用顶点索引对应起来
		1.7.2.测试用例
		1.7.3.实现：
			用了3种数据结构：
				一个符号表st，键的类型为String顶点名，值的类型为int索引
				一个数据key[]，用作反响索引，保存每个顶顶索引对应的顶点名
				一个Graph对象G,它使用索引来引用图中的顶点
			SymbolGraph会遍历两遍数据结构来构造以上数据，
			主要是因为构造Graph对象需要顶点总数V
		1.7.4.间隔的度数
2.有向图
	在有向图中，边是单向的：
		每条边所连接的两个顶点都是一个有序对，它们的邻接性都是单向的
	2.1.术语
		一个有向图是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点
		一条有向边：
			是由第一个顶点指出并指向第二个顶点
		一个顶点的出度为该顶点指出边的总数
		一个顶点的入度为指向该顶点边的总数
		一条有向边的第一个顶点成为头，第二个顶点成为尾
		用v→w表示有向图中的一条由v指向w的边
		一副有向图中的两个顶点的关系有4种：
			没有边相连
			存在从v到w的边 v→w；
			存在从w到v的边 w→v；
			既存在从v到w，也从w到v，即双向连接
		当存在从v到w的路径时，称顶点w能够由顶点v到达
	2.2.有向图的数据类型
		public class Digraph
			Digraph(int v) 创建一副含有v个顶点但是没有边的有向图
			Digraph(In in) 从输入流in中读取一副有向图
			int V()		顶点总数
			int E()      边的总数
			void addEdge(int v,int w)		在向有向图中添加一条边v->w
			Digraph reverse()	该图的反向图
			String toString()    对象的字符串表示
		2.2.1.有向图的表示
			其中边v到w表示为顶点v所对应的连接表中包含一个w顶点。
		2.2.2.输入格式
		2.2.3.有向图取反
			reverse()返回有向图的一个副本，但是将其中所有的边方向反转
			adj()给出的是每个顶点指出的边所连接的所有顶点。
		2.2.4.顶点的符号名
			允许用例使用符号作为顶点名也更加简单
	2.3.有向图的可达性
		是否存在一条s到达给定顶点v的有向路径
		public class DirectedDFS
			DirectedDFS(Digraph G, int s)	//在G中找到s可达的所有顶点
			DirectedDFS(Digraph G, Iterable<Integer> source)	在G中找到从source中的所有顶点可达的所有顶点
			boolean marked(int v)	//v是可达的么
		2.3.1.标价-清楚垃圾收集
			在一副有向图中，一个顶点代表一个对象，一条边则表示一个对象对另一个对象的引用
			标记清楚垃圾回收策略会为每个对象保留一个位做垃圾收集之用。
			它会周期性地运行一个类似于DigrphDFS的有图可达性算法来标记所有被访问的对象，然后清理对象，回收没有被标记的对象。
		2.3.2.有向图的寻路
	2.4.环和有向五环图
		2.4.1.调度问题
			给定一组任务并安排它们执行的顺序，限制条件是这些任务执行方法和起始时间
			限制条件还可能包括任务的消耗以及消耗其他资源
			最重要的一条限制叫做优先级限制
			拓扑排序：
				给顶一副有向图，将所有的顶点排序，使得是所有的有向图均从排在前面的元素
		2.4.2.有向图中的环
			如果一个优先级问题中存在有向环，那么这个问题肯定是无解的，要检查这种错误，肯定需要解决下面的问题
			有向环检测：
				给定的有向图中包含有向环么
				如果有，按照路径的方向从某个顶点并返回自己来找到环上的所有顶点
			一副有向图中含有的环的数量可能是图的大小的指数级别
				因此我们需要找出一个环即可，而不是所有环
			解决一幅有向图是有向无环图么？
				因为由于系统维护的递归调用的栈表示的正式“当前”正在遍历的有向路径
				一旦找到一条边v→w且w已经在栈中，就找到了一个环，因为栈表示的是一条有w到v的有向路径
				  而v→w正好补全了这个环。
				  同时，如果没有这个边那就意味着这幅有向图是无环的
			public class DirectedCycle
				DirectedCycle(Digraph G)	寻找有向环的构造函数
				boolean hasCycle()	G是否含有有向环
				Iterable<Integer> cycle()	有向环中的所有顶点（如果存在）
		2.4.3.顶点的深度优先次序与拓铺排序
			public class Topologcial
				Topologcial()	拓铺排序的构造函数
				bollean isDAG()	G是有向无环图么？
				Iterable<Integer> ordec	拓铺排序的所有顶点\
			当且仅当一副有向图是无环图时它才能进行拓扑排序
			3中排泄顺序：
				前序：在递归调用之前将顶点加入队列
				后序：在递归调用之后将顶点加入队列
				逆后续：在递归调用之后，将顶点压入栈
			一副有向五环图的拓扑排序即为所有顶点的逆后续排列。