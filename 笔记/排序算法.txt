排序算法166

1.1.初级排序算法
	1.1.1游戏规则
		排序算法的目标就是将所有元素的主键按照某种方式排列
		排序后索引较大的主键
		会将排序代码放在sort()中，包含辅助函数less(),exch()
	1.1.3
		排序算法的额外内存开销和运行时间是同等重要的，分为两类
			函数调用所需的栈和固定数目的实例之外无需额外内存的原始排序算法
			需要额外内存来存储另一份副本的其他排序算法。
	1.1.4.数据类型
		CompareTo()必须实现一个完整的比较序列
			自反性
			反对称性
			传递性
1.2.选择排序
	a.找到数据里面最小的那个元素
	b.将它和数组的第一个元素交换位置
	c.在剩下的元素中找到最小的
	d.将它与数组第二个交换位置
	不断的选择剩余元素之中的最小者
	选择排序的内循环只是比较当前元素与已知的最小元素，以及将当前索引+1和检查代码是否出界。
	交换元素的代码写在内循环里里面，每次交换总能排定一个元素，因此交换的总此时是N
	对于长度为N的数组，选择排序需要大约N²/2次比较和N次交换
	时间复杂度O(N²)
	两个鲜明的特点：
		运行时间和输入无关
		数据移动最少
1.3.插入排序
	为了给插入的元素腾空间，我们需要将其余所有的元素在插入之前都向右移动一位
	与选择排序一样，当前索引左边的所有元素都是有序的，但是他们的最终位置还不确定
	为了给更小的元素腾空间，他们可能会被移动，当索引到达数组右端的时候，数组排序就完成。
	与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序
	对于随机排列的长度为N且主键不重复的数组，平均情况下排序需要 N²/4次比较 以及N²/4交换
	时间复杂度为O(N²)，最好的情况是O(N)
	应用中就是非随即数组
1.4.排序算法的可视化
1.5.比较选择和排序
	对于随机排序的无重复主键的数据，插入排序和选择排序的运行时间是平方级别的，两者之比应该是个小数。
1.6.希尔排序
	基于插入排序的快速排序是算法
	交换不相邻的元素以对数组的局部排序，并且最终用插入排序将局部有序数组排序。
	思想使数组中任意为h的元素都是有序的，这样的数组成为h有序数据
	一个h有序数组就是h个互相独立有序数组编织在一起成为一个新的数组
	实现希尔排序对于每个h，用插入排序将h个子数组独立的排序
	更高效权衡了子数组的规模和有序性
	希尔排序最好时间复杂度和平均时间复杂度都是这里写O(nlogn)，最坏时间复杂度为O(n²)。
2.2.归并排序
	将两个有序数组归并成一个更大的有序数组
	要将一个数组排序，可以先递归将它分成两半分别排序，然后将结果归并起来。
	将任意长度为N的数组排序所需的时间和NlogN成正比
	归并排序的最好、最坏和平均时间复杂度都是O(nlogn)
	主要缺点它所需的额外空间和N成正比
	2.2.1.原地归并的抽象方法
		实现归并的一种直接了当的方法就是将两个不同的有序数组归并到第三个数组中。
	2.2.2.自顶向下的归并排序
		递归归并
		分治思想
		如果能将两个子数组排序，它就能通过归并两个子数组来将整个数组排序
		2.2.2.1.对小规模子数组使用插入排序
			用不同方法处理小规模问题能改进大多数递归算法的性能
		2.2.2.2.测试数组是否已经有序
			添加一个判断条件 a[mid] <= a[mid+1],数组已经有序并跳过merge()
		2.2.2.3.不将元素复制到辅助数组
			节省将数组元素复制用于归并的辅助数组所用的时间，空间不行
			要调用两种排序方法
				将数据从输入数组排序到辅助数组
				将数据从辅助数组排序到输入数组
	2.2.3.自底向上的归并排序
		递归实现归并排序是算法设计中分治思想的典型应用
		先归并微型数组，然后在成对归并得到子数组
	2.2.4.排序算法的复杂度
		建立模型
			没有任何基于比较的算法能保证使用少于lg(N！)~NlgN次比较将长度为N的数组排序。	
		归并排序是一种最优的基于比较排序的算法

2.3.快速排序
	2.3.1。基本算法
		是一种分治的基本算法。
		将一个数组分成两个子数组，将两部分独立排序。
		归并排序是将数组分成两个子数组分别排序，并将两个子数组归并以将整个数组排序
			递归调用发生在处理整个数组之前
			一个数组被分为两半
		快速排序当两个子数组都有序的时整个数组自然也就有序
			递归调用处理在整个数组之后
			切分的内容取决于数组的内容
		
		2.3.1.1.原地切分
		2.3.1.2.别越界
		2.3.1.3.保持随机性
		2.3.1.4.终止循环
		2.3.1.5.处理切分元素值有重复情况
	2.3.3.算法改进
		2.3.3.1.切换到插入排序
			对于小数组，快速排序比插入排序慢
			因为递归，快速排序的sort()方法在小数组中也会调用自己
		2.3.3.2.三取样切分
			使用 子数组的一小部分元素的中位数来切分数组，这样做切分更好，但是代价需要计算中位数。
			发现取样大小设为3并用大小居中的元素切分效果最好
		2.3.3.3.熵最优排序
2.4.优先队列
	一个合适的数据结构应该支持两种操作：删除最大元素和插入元素，叫优先队列
	应用场景
		模拟系统：事件的键即为发生时间，而系统需要按照时间顺序来处理所有事件
				  任务调度，键值的优先级决定了应该首先执行哪些任务
				  数值计算，键值代表计算错误。
	2.4.1.API
	2.4.2.初级实现
		2.4.2.1.数组实现 无序
			insert()方法的代码和栈的push()方法完全一样
			实现删除最大元素，添加一段类似于选择排序的内循环，将最大元素和边界元素交换然后删除它
			  对栈的pop()方法实现一样
		2.4.2.2.数组实现 有序
			在insert()中添加代码，将所有较大的元素向右边移动一格以使数据保持有序
			   最大的元素总会在数组一边，有限队列的删除最大元素操作就和栈的pop()一样了。
		2.4.2.3.链表表示发法
			基于链表的下压栈码作为基础，而后可以选择修改Pop()来找到并返回最大元素
			或者修改push()来保证所有元素为逆序并用pop()来删除并返回链表的首元素。
			对于栈和队列，我们的实现能够在常数时间内完成所有操作，而面对优先队列
			插入元素和删除元素在最坏的情况下需要线性完成
	2.4.3.堆的定义
		在二叉堆中，每个元素都要保证大于等于另两个特定位置的元素，这些位置的元素又要大于或等于数组
		   中的另两个元素。
		当一颗二叉树的每个结点都大于等于它的两个子节点时，成为堆有序
		根结点就是堆有序的二叉树的最大结点
		二叉堆表示法
			将二叉树的结点按照层级顺序放入数组中，根节点的位置在1，子节点的位置在2，3，
			  子节点的子节点位置分别在4，5，6，7
		二叉堆是一组能够使用堆有序的完全二叉树排序的元素，并在数据中按照层级储存，不使用数组的第一个元素
		位置为k的结点的父节点的位置为[k/2]，子节点为2k和2k+1,
		可以计算数组的索引在树上移动：
			从a[k]向上一层就令k=k/2,向下一层则令k=2k或2k+1
		一颗大小为N的完全二叉树的高度为lgN
	2.4.4.堆的算法
		用长度为N+1的私有数组pq[]来表示一个大小为N的堆
		堆元素从pq[1]到pq[N]
		堆的操作会首先进行一些简单的改动，打破堆的状态，然后在遍历堆并按照要求将堆的状态回复。堆有序化
		两种情况：
			当某个结点的优先级上升，或者在堆底加入一个新的元素，需要由下至上恢复堆的顺序
			当某个节点的优先级下降，将根节点替换为一个较小的元素，需要由上至下恢复堆的顺序
		2.4.4.1.由下至上的堆的有序化 上升
			如果堆的有序状态因为某个结点变得比它的父节点还的大而被打破，
			   需要交换这个结点和父节点来修复堆。循环
			位置k的节点的父结点的位置[k/2]
		2.4.4.2.由上至下的对有序下沉
			如果对的有序状态因为某个节点变得比它两个子节点就是更小而被打破，那么我们可以通过将它
			  它的两个子节点中的较大者交换来恢复堆。
			位置k的子节点位于2k和2k+1
		2.4.4.3.多叉堆
			对于数组的1到N的N个元素，位置k的节点大于等于位于3k-1，3k,3k+1的节点，小于等于
			   位于(K+1)/3的节点
		2.4.4.4.调整数组的大小
			在insert（）中添加将数组长度减半的代码
		2.4.4.5.元素的不可变性
		2.4.4.6.索引的优先队列
			允许用例已经进入优先队列中的元素是有必要的
			做到这一点的一种简单方法是给每个元素增加一个索引
	2.4.5.堆排序
		两个阶段：
			在堆的构造阶段中，将原始数组重新安排进一个堆中，
			在下沉排序阶段，从堆中按递减顺序取出所有元素并得到排序结果。
		2.4.5.1.堆的构造
			用下沉操作由N个元素构造堆只少于2N次比较以及少于N次交换
		2.4.5.2.下沉排序
			将N个元素排序，对排序只少于(2NlgN+2N)次比较
		