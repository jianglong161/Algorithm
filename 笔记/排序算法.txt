排序算法166

1.1.初级排序算法
	1.1.1游戏规则
		排序算法的目标就是将所有元素的主键按照某种方式排列
		排序后索引较大的主键
		会将排序代码放在sort()中，包含辅助函数less(),exch()
	1.1.3
		排序算法的额外内存开销和运行时间是同等重要的，分为两类
			函数调用所需的栈和固定数目的实例之外无需额外内存的原始排序算法
			需要额外内存来存储另一份副本的其他排序算法。
	1.1.4.数据类型
		CompareTo()必须实现一个完整的比较序列
			自反性
			反对称性
			传递性
1.2.选择排序
	a.找到数据里面最小的那个元素
	b.将它和数组的第一个元素交换位置
	c.在剩下的元素中找到最小的
	d.将它与数组第二个交换位置
	不断的选择剩余元素之中的最小者
	选择排序的内循环只是比较当前元素与已知的最小元素，以及将当前索引+1和检查代码是否出界。
	交换元素的代码写在内循环里里面，每次交换总能排定一个元素，因此交换的总此时是N
	对于长度为N的数组，选择排序需要大约N²/2次比较和N次交换
	时间复杂度O(N²)
	两个鲜明的特点：
		运行时间和输入无关
		数据移动最少
1.3.插入排序
	为了给插入的元素腾空间，我们需要将其余所有的元素在插入之前都向右移动一位
	与选择排序一样，当前索引左边的所有元素都是有序的，但是他们的最终位置还不确定
	为了给更小的元素腾空间，他们可能会被移动，当索引到达数组右端的时候，数组排序就完成。
	与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序
	对于随机排列的长度为N且主键不重复的数组，平均情况下排序需要 N²/4次比较 以及N²/4交换
	时间复杂度为O(N²)，最好的情况是O(N)
	应用中就是非随即数组
1.4.排序算法的可视化
1.5.比较选择和排序
	对于随机排序的无重复主键的数据，插入排序和选择排序的运行时间是平方级别的，两者之比应该是个小数。
1.6.希尔排序
	基于插入排序的快速排序是算法
	交换不相邻的元素以对数组的局部排序，并且最终用插入排序将局部有序数组排序。
	思想使数组中任意为h的元素都是有序的，这样的数组成为h有序数据
	一个h有序数组就是h个互相独立有序数组编织在一起成为一个新的数组
	实现希尔排序对于每个h，用插入排序将h个子数组独立的排序
	更高效权衡了子数组的规模和有序性
	希尔排序最好时间复杂度和平均时间复杂度都是这里写O(nlogn)，最坏时间复杂度为O(n²)。
2.2.归并排序
	将两个有序数组归并成一个更大的有序数组
	要将一个数组排序，可以先递归将它分成两半分别排序，然后将结果归并起来。
	将任意长度为N的数组排序所需的时间和NlogN成正比
	归并排序的最好、最坏和平均时间复杂度都是O(nlogn)
	主要缺点它所需的额外空间和N成正比
	2.2.1.原地归并的抽象方法
		实现归并的一种直接了当的方法就是将两个不同的有序数组归并到第三个数组中。
	2.2.2.自顶向下的归并排序
		递归归并
		分治思想
		如果能将两个子数组排序，它就能通过归并两个子数组来将整个数组排序
		2.2.2.1.对小规模子数组使用插入排序
			用不同方法处理小规模问题能改进大多数递归算法的性能
		2.2.2.2.测试数组是否已经有序
			添加一个判断条件 a[mid] <= a[mid+1],数组已经有序并跳过merge()
		2.2.2.3.不将元素复制到辅助数组
			节省将数组元素复制用于归并的辅助数组所用的时间，空间不行
			要调用两种排序方法
				将数据从输入数组排序到辅助数组
				将数据从辅助数组排序到输入数组
	2.2.3.自底向上的归并排序
			
		