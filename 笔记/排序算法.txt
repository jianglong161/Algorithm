排序算法166

1.1.初级排序算法
	1.1.1游戏规则
		排序算法的目标就是将所有元素的主键按照某种方式排列
		排序后索引较大的主键
		会将排序代码放在sort()中，包含辅助函数less(),exch()
	1.1.3
		排序算法的额外内存开销和运行时间是同等重要的，分为两类
			函数调用所需的栈和固定数目的实例之外无需额外内存的原始排序算法
			需要额外内存来存储另一份副本的其他排序算法。
	1.1.4.数据类型
		CompareTo()必须实现一个完整的比较序列
			自反性
			反对称性
			传递性
1.2.选择排序
	a.找到数据里面最小的那个元素
	b.将它和数组的第一个元素交换位置
	c.在剩下的元素中找到最小的
	d.将它与数组第二个交换位置
	不断的选择剩余元素之中的最小者
	选择排序的内循环只是比较当前元素与已知的最小元素，以及将当前索引+1和检查代码是否出界。
	交换元素的代码写在内循环里里面，每次交换总能排定一个元素，因此交换的总此时是N
	对于长度为N的数组，选择排序需要大约N²/2次比较和N次交换
	时间复杂度O(N²)
	两个鲜明的特点：
		运行时间和输入无关
		数据移动最少
1.3.插入排序
	为了给插入的元素腾空间，我们需要将其余所有的元素在插入之前都向右移动一位
	与选择排序一样，当前索引左边的所有元素都是有序的，但是他们的最终位置还不确定
	为了给更小的元素腾空间，他们可能会被移动，当索引到达数组右端的时候，数组排序就完成。
	与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序
	对于随机排列的长度为N且主键不重复的数组，平均情况下排序需要 N²/4次比较 以及N²/4交换
	时间复杂度为O(N²)，最好的情况是O(N)
	应用中就是非随即数组
1.4.排序算法的可视化
1.5.比较选择和排序
	对于随机排序的无重复主键的数据，插入排序和选择排序的运行时间是平方级别的，两者之比应该是个小数。
1.6.希尔排序
	基于插入排序的快速排序是算法
	交换不相邻的元素以对数组的局部排序，并且最终用插入排序将局部有序数组排序。
	思想使数组中任意为h的元素都是有序的，这样的数组成为h有序数据
	一个h有序数组就是h个互相独立有序数组编织在一起成为一个新的数组
	实现希尔排序对于每个h，用插入排序将h个子数组独立的排序
	更高效权衡了子数组的规模和有序性