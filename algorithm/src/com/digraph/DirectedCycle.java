package com.digraph;

import java.util.Stack;

import com.graph.In;
/**
 * 寻找有向环
 * @author Still2Almost
 *
 */
public class DirectedCycle {
	private boolean[] marked;
	private int[] edgeTo;
	private Stack<Integer> cycle;//有向环中所有顶点
	private boolean[] onStack;	//递归调用栈上的所有顶点
	public DirectedCycle(Digraph G) {
		onStack = new boolean[G.V()];
		edgeTo = new int[G.V()];
		marked = new boolean[G.V()];
		for(int v = 0; v < G.V();v++){
			if(!marked[v])
				dfs(G,v);
		}
		
	}
	/**
	 * 添加了一个布尔类型的数组onStack[]来保存递归调用期间的栈上的所有顶点
	 * 当它找到了一条边v到w的且在w在栈中，它就找到了一个环
	 * @param G
	 * @param v
	 */
	private void dfs(Digraph G, int v){
		onStack[v] = true;
		marked[v] = true;
		for(int w : G.adj(v)){
			if(this.hasCycle()	)
				return;
			else if(onStack[w]){
				cycle = new Stack<Integer>();
				for(int x = v; x != w;x = edgeTo[x]){
					cycle.push(x);
				}
				cycle.push(w);
				cycle.push(v);
			}
			onStack[w] = false;
		}
	}
	public boolean hasCycle(){
		return cycle != null;
	}
	public Iterable<Integer> cycle(){
		return cycle;
	}
}
